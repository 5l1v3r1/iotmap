<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>iotmap.database.nodesdatabase API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>iotmap.database.nodesdatabase</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from neo4j import GraphDatabase
import sys
import os.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))
from scapy.utils import hexdump

class NodesDatabase(object):
    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))
                
    def close(self):
        self._driver.close()

    # Delete all nodes
    @classmethod
    def delete_nodes(cls, tx, label):
        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        where n.label &gt;= $label
        optional match (n)-[r]-()
        delete r, n&#34;&#34;&#34;, label=label
        )
        
    @classmethod
    def delete_transmissions(cls, tx):
        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        optional match (n)-[r]-()
        delete r&#34;&#34;&#34;
        )

    # Delete all visual nodes 
    @classmethod
    def delete_visu_nodes(cls, tx, label):
        if label &gt; 3:
            return None
        
        if label == 2:
            tx.run(&#34;&#34;&#34;
            MATCH (n: Node)
            where n.label = &#39;l2&#39;
            optional match (n)-[r]-()
            delete r, n&#34;&#34;&#34;
            )

        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        where n.label = &#39;l3&#39;
        optional match (n)-[r]-()
        delete r, n&#34;&#34;&#34;
        )

    # Create a node with its properties
    @classmethod
    def create_node(cls, tx, node):
        nameID, dlsrc, nwksrc, label, role = node
        tx.run(&#39;&#39;&#39;
            merge (n: Node {label: $label, nameID: $nameID, dlsrc: $dlsrc, nwksrc: $nwksrc, role:$role})
        &#39;&#39;&#39;, label=label, nameID=nameID, dlsrc=dlsrc, nwksrc=nwksrc, role=role)

    # Duplicate all nodes that is useful to create independant graph
    # for each layer.
    @classmethod
    def duplicate_node(cls, tx, label_src, label_dst):
         tx.run(&#34;&#34;&#34;
         match (n:Node {label: $label_src}) 
         with n as map 
         create (copy:Node {label: $label_dst}) 
         set copy.nameID = map.nameID, copy.dlsrc = map.dlsrc, copy.nwksrc = map.nwksrc, copy.neighbors = map.neighbors, copy.role = map.role
         &#34;&#34;&#34;, label_src=label_src, label_dst=label_dst
         )
    

    # This function allows a better insight of the link between nodes at layer 2
    @classmethod
    def node_visu_dllink(cls, tx, label):
        tx.run(&#34;&#34;&#34;
        match ()-[r: dlLink]-&gt;() 
        match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) 
        where (r.dlsrc in n_src.dlsrc) and r.dldst in n_dst.dlsrc
        merge (n_src)-[:layer2]-&gt;(n_dst)&#34;&#34;&#34;, label=label)

    # Simpler view of the nwk graph where only one edge is drawed between
    # two nodes
    @classmethod
    def node_visu_nwklink(cls, tx, label):
        tx.run(&#34;match ()-[r:nwkLink]-&gt;() &#34;
               &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
               &#34;where (r.nwksrc in n_src.nwksrc) and r.nwkdst in n_dst.nwksrc &#34;
               &#34;merge (n_src)-[:layer3]-&gt;(n_dst)&#34;,
               label=label
        )

    # Simpler view of the trans graph where only one type of application is
    # displayed
    @classmethod
    def node_visu_translink(cls, tx):
        tx.run(&#34;&#34;&#34;
        match (n)-[rl3: layer3]-&gt;(m)
        match (n2: Node{label:&#39;5&#39;})-[r]-&gt;(m2: Node{label:&#39;5&#39;}) 
        where n2.nwksrc in n.nwksrc and m2.nwksrc in m.nwksrc
        merge (n)-[:type(r)]-&gt;(m)
        with rl3
        delete rl3
        &#34;&#34;&#34;)

    # Create edges corresponding to the data link communications
    @classmethod
    def node_transmission(cls, tx, properties):
        dlsrc, dldst = properties[&#39;dlsrc&#39;], properties[&#39;dldst&#39;] 
        tx.run( &#34;&#34;&#34;
        match (n_src: Node) 
        where $dlsrc in n_src.dlsrc 
        match (n_dst: Node) 
        where $dldst in n_dst.dlsrc 
        create (n_src)-[:dlLink $properties]-&gt;(n_dst)&#34;&#34;&#34;, 
        dlsrc=dlsrc, dldst = dldst, properties=properties)

    # Create edges corresponding to the network communications
    @classmethod
    def nwk_transmission(cls, tx, label):  
        tx.run(&#34;match ()-[r_g2:dlLink]-&gt;() &#34;
               &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
               &#34;where (r_g2.dlsrc in n_src.dlsrc and r_g2.nwksrc in n_src.nwksrc) and r_g2.nwkdst in n_dst.nwksrc &#34;
               &#34;create (n_src)-[r:nwkLink { timestamp: r_g2.timestamp, dlsrc: r_g2.dlsrc, dldst: r_g2.dldst, nwksrc: r_g2.nwksrc, nwkdst: r_g2.nwkdst, apptype: r_g2.apptype, data: r_g2.data} ]-&gt;(n_dst)&#34;,
               label=label
        )

    @classmethod
    def transport_transmission(cs, tx, delta, delta2):
        #delta = .6 # It is the time delta between a request and the response

        delta = delta
        
        # Get the source and destination nodes along with their
        # edges according to the apptype
        # results = tx.run(&#34;&#34;&#34;
        # match ()-[r_g3:nwkLink]-&gt;()
        # match (n_src: Node {label: &#39;g3&#39;}), (n_dst: Node {label: &#39;g3&#39;})
        # where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
        # with n_src, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
        # return n_src.nameID, nsrc, mdst, collect(distinct tp)
        # &#34;&#34;&#34;).values()

        results = tx.run(&#34;&#34;&#34;
        match ()-[r_g3:nwkLink]-&gt;()
        match (n_src: Node {label: 3}), (n_dst: Node {label: 3})
        where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
        with n_src.nameID as srcID, n_dst.nameID as dstID, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
        return srcID, nsrc, dstID, mdst, collect(distinct tp)
        &#34;&#34;&#34;).values()

        transNodes = {}
        dstNodes = {}
        label=4
        
        for line in results:
            srcID, srcN, dstID, dstN, txG = line
            dstNodes = {
                dstID: txG
            }
            if srcID in transNodes.keys():
                transNodes[srcID].update(dstNodes)
            else:
                transNodes[srcID] = dstNodes
                transNodes[srcID][&#39;id&#39;] = srcID
                transNodes[srcID][&#39;role&#39;] = []

        # logging.debug(transNodes)
                
        for src in transNodes.keys():
            for dst in transNodes[src].keys():
                if &#39;role&#39; == dst or &#39;id&#39; == dst:
                    continue
                    
                # Communication are only one-way
                source = src
                sink = dst
                
                # Dst only received so Dst is a sink
                # And so we are a one way communication
                if not dst in transNodes.keys():
                    if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                        transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                    srcRole = list(set(transNodes[src][&#39;role&#39;]))
                    dstRole = [&#39;sink&#39;]
                    tx.run(&#34;&#34;&#34;
                    match (n: Node{label: $label}), (m: Node{label: $label})
                    where $srcID = n.nameID and $dstID = m.nameID
                    merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                    on create set n.role = n.role + $srcRole, m.role = m.role + $dstRole
                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=transNodes[source][sink])

                # here we have a one-way communication src to dst
                elif src not in transNodes[dst].keys():
                    if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                        transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                    if &#39;sink&#39; not in transNodes[dst][&#39;role&#39;]:
                        transNodes[dst][&#39;role&#39;].append(&#39;sink&#39;)
                        
                    srcRole = list(set(transNodes[src][&#39;role&#39;]))
                    dstRole = list(set(transNodes[dst][&#39;role&#39;]))
                    tx.run(&#34;&#34;&#34;
                    match (n: Node{label: $label}), (m: Node{label: $label})
                    where $srcID = n.nameID and $dstID = m.nameID
                    merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                    on create set n.role = $srcRole, m.role = $dstRole
                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole = srcRole, dstRole = dstRole, ts=transNodes[source][sink])

                # bidirectionnal communications
                else:
                    tx1 = transNodes[src][dst]
                    tx2 = transNodes[dst][src]

                    lentx1 = len(tx1)
                    lentx2 = len(tx2)

                    #j = 0
                    for t2 in tx2:
                        #for i in range(j, lentx1):
                        for t1 in tx1:
                            #t1 = tx1[i]
                            if t2 &gt; t1 :
                                if t2 - t1 &lt; delta:

                                    #logging.debug(f&#39;TRANSEdge created: {dst} -&gt; {src} with {t2} - {t1}&#39;)
                                    
                                    if &#39;source&#39; not in transNodes[dst][&#39;role&#39;]:
                                        transNodes[dst][&#39;role&#39;].append(&#39;source&#39;)
                                    if &#39;sink&#39; not in transNodes[src][&#39;role&#39;]:
                                        transNodes[src][&#39;role&#39;].append(&#39;sink&#39;)
                                    source = dst
                                    sink = src
                                    srcRole = list(set(transNodes[source][&#39;role&#39;]))
                                    dstRole = list(set(transNodes[sink][&#39;role&#39;]))
                                    tx.run(&#34;&#34;&#34;
                                    match (n: Node{label: $label}), (m: Node{label: $label})
                                    where $srcID = n.nameID and $dstID = m.nameID
                                    merge (n)-[: TRANSEdge {timestamp: $ts, nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
                                    on create set n.role=$srcRole, m.role=$dstRole
                                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=tx2)
                                    #j = i
                                    #break
                            else:
                                continue

        #Let&#39;s create controller
        results = tx.run(&#34;&#34;&#34;
        match (n: Node{label: 4})-[r1]-(m: Node{label: 4})-[r2]-(d: Node{label: 4})
        where (&#39;source&#39; in n.role or &#39;controller&#39; in n.role) and (&#39;source&#39; in m.role and &#39;sink&#39; in m.role) and (&#39;sink&#39; in d.role or &#39;controller&#39; in d.role) and n &lt;&gt; d
        with r1.nwksrc as src, r1.nwkdst as ctrl, r2.nwkdst as sink, r1.timestamp as ts1, r2.timestamp as ts2
        return src, ctrl, sink, ts1, ts2
        &#34;&#34;&#34;).values()

        #delta2 = .7
        delta2 = delta2
        
        for line in results:
            source, controller, sink, ts1, ts2 = line

            if isinstance(controller, list):
                controller = controller[0]
            
            for t2 in ts2:
                for t1 in ts1:
                # we get a controller
                    if t2 &gt; t1 and t2 - t1 &lt; delta2:

                        #logging.debug(f&#39;Controller set: {controller} with {source} and {sink} with {t2} - {t1}&#39;)
                        
                        tx.run(&#34;&#34;&#34;
                        match (n: Node{label: $label})
                        where $ctrl in n.nwksrc
                        set n.role = [&#39;controller&#39;]
                        &#34;&#34;&#34;, label=label, ctrl=controller)
        
        
    # Create edges corresponding to the application communications
    # Currently only support AS scheme
    @classmethod
    def application_transmission(cs, tx, delta):
        #delta = 1.5
        delta = delta

        # Select all nodes and edges (here represented by path p) that are involved 
        # in an actuator-sensor scheme.
        results = tx.run(&#34;&#34;&#34;
        match p=(n:Node{label: 4})-[:TRANSEdge*1..]-&gt;(c: Node{label: 4})-[:TRANSEdge*1..]-&gt;(m:Node{label: 4})
        where &#39;source&#39; in n.role and &#39;sink&#39; in m.role and n &lt;&gt; m and &#39;controller&#39; in c.role
        return p
        &#34;&#34;&#34;)

        for result in results:
            nbRel = len(result[&#34;p&#34;].relationships)
            rel = result[&#34;p&#34;].relationships
            count = 1
            for i in range(1, nbRel):
                TX1 = rel[i - 1][&#39;timestamp&#39;]
                TX2 = rel[i][&#39;timestamp&#39;]
                for t2, t1 in ((tx2, tx1) for tx2 in TX2 for tx1 in TX1):
                    if t2 &gt; t1 and t2 - t1 &lt; delta:
                        count += 1
                        break
                    

            #logging.debug(f&#39;Count: {count} and nbRel: {nbRel}&#39;)
            # All relationships are succeeded
            if count == nbRel:
                source, dest1 = rel[0].nodes
                dest1, sink = rel[-1].nodes
                
                tx.run(&#34;&#34;&#34;
                match (n: Node{label: 5}), (m: Node{label: 5})
                where n.nameID = $nameIdn and m.nameID = $nameIdm
                Merge (n)-[: INTERACT {nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
                &#34;&#34;&#34;, nameIdn=source[&#39;nameID&#39;], nameIdm=sink[&#39;nameID&#39;])


    ####
    ###  Following functions are wrappers called by the databaseController 
    ####

    # Call the trans_transmission function to store all the communciations
    # between nodes
    def transGraph(self, delta, delta2):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 2, 4)
            session.write_transaction(self.transport_transmission, delta, delta2)

    # Call the trans_transmission function to store all the communciations
    # between nodes
    def appGraph(self, delta):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 4, 5)
            session.write_transaction(self.application_transmission, delta)

    # Call the nwk_transmission function to store all the communciations
    # between nodes
    def nwkGraph(self):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 2, 3)
            session.write_transaction(self.nwk_transmission, 3)

            session.write_transaction(self.node_visu_nwklink, &#39;l2&#39;)

    # Call the node_transmission function to store all the communciations
    # between nodes
    def create_nodesTX(self, nodesTX):
        with self._driver.session() as session:
            for t in nodesTX:
                session.write_transaction(self.node_transmission, nodesTX[t])

            session.write_transaction(self.duplicate_node, 2, &#39;l2&#39;)
            session.write_transaction(self.node_visu_dllink, &#39;l2&#39;)

    # Handle the creation of multiple nodes
    # using the neo4j syntax
    def create_nodes(self, nodes):
        with self._driver.session() as session:
            for n in nodes:
                session.write_transaction(self.create_node, n)

    def del_nodes(self, label):
        with self._driver.session() as session:
            session.write_transaction(self.delete_nodes, label)
            session.write_transaction(self.delete_visu_nodes, label)

    def getResults(self):
        values = &#39;&#39;  
        with self._driver.session() as session:
            values = session.run(&#34;&#34;&#34;
                with [&#39;TRANSEdge&#39;, &#39;INTERACT&#39;] as t
                match (n)-[r]-(m)
                where n.nwksrc = r.nwksrc and type(r) in t
                return n.nwksrc, n.role, m.nwksrc, m.role, type(r)
             &#34;&#34;&#34;).values()
        return values

    def getNodes(self):
        with self._driver.session() as session:
            nodes = session.run(&#34;&#34;&#34;
                MATCH (n:Node) 
                with n.nameID as id, n.nwksrc as nwk, n.dlsrc as dl 
                return id, dl, nwk&#34;&#34;&#34;).values()
        return nodes 


    def getNode(self, nodeID):
        with self._driver.session() as session:
            node = session.run(&#34;&#34;&#34;
                MATCH (n:Node)
                where n.nameID = $nodeID
                with n.nameID as id, n.dlsrc as dl, n.nwksrc as nwk
                return id, dl, nwk
                &#34;&#34;&#34;, nodeID = nodeID).values()

        return node[0]

    def maxID(self):
        with self._driver.session() as session:
            maxID = session.run(&#34;&#34;&#34;
                MATCH (n:Node) RETURN MAX(n.nameID)
                &#34;&#34;&#34;).values()

        return maxID[0]

    def removeTX(self):
        with self._driver.session() as session:
            session.write_transaction(self.delete_transmissions)
        
    def removeNode(self, nodeID):
        with self._driver.session() as session:
            ret = session.run(&#34;&#34;&#34;
                MATCH (n:Node)
                where n.nameID = $nodeID
                delete n
                &#34;&#34;&#34;, nodeID = nodeID).values()

        return ret</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="iotmap.database.nodesdatabase.NodesDatabase"><code class="flex name class">
<span>class <span class="ident">NodesDatabase</span></span>
<span>(</span><span>uri, user, password)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodesDatabase(object):
    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))
                
    def close(self):
        self._driver.close()

    # Delete all nodes
    @classmethod
    def delete_nodes(cls, tx, label):
        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        where n.label &gt;= $label
        optional match (n)-[r]-()
        delete r, n&#34;&#34;&#34;, label=label
        )
        
    @classmethod
    def delete_transmissions(cls, tx):
        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        optional match (n)-[r]-()
        delete r&#34;&#34;&#34;
        )

    # Delete all visual nodes 
    @classmethod
    def delete_visu_nodes(cls, tx, label):
        if label &gt; 3:
            return None
        
        if label == 2:
            tx.run(&#34;&#34;&#34;
            MATCH (n: Node)
            where n.label = &#39;l2&#39;
            optional match (n)-[r]-()
            delete r, n&#34;&#34;&#34;
            )

        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        where n.label = &#39;l3&#39;
        optional match (n)-[r]-()
        delete r, n&#34;&#34;&#34;
        )

    # Create a node with its properties
    @classmethod
    def create_node(cls, tx, node):
        nameID, dlsrc, nwksrc, label, role = node
        tx.run(&#39;&#39;&#39;
            merge (n: Node {label: $label, nameID: $nameID, dlsrc: $dlsrc, nwksrc: $nwksrc, role:$role})
        &#39;&#39;&#39;, label=label, nameID=nameID, dlsrc=dlsrc, nwksrc=nwksrc, role=role)

    # Duplicate all nodes that is useful to create independant graph
    # for each layer.
    @classmethod
    def duplicate_node(cls, tx, label_src, label_dst):
         tx.run(&#34;&#34;&#34;
         match (n:Node {label: $label_src}) 
         with n as map 
         create (copy:Node {label: $label_dst}) 
         set copy.nameID = map.nameID, copy.dlsrc = map.dlsrc, copy.nwksrc = map.nwksrc, copy.neighbors = map.neighbors, copy.role = map.role
         &#34;&#34;&#34;, label_src=label_src, label_dst=label_dst
         )
    

    # This function allows a better insight of the link between nodes at layer 2
    @classmethod
    def node_visu_dllink(cls, tx, label):
        tx.run(&#34;&#34;&#34;
        match ()-[r: dlLink]-&gt;() 
        match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) 
        where (r.dlsrc in n_src.dlsrc) and r.dldst in n_dst.dlsrc
        merge (n_src)-[:layer2]-&gt;(n_dst)&#34;&#34;&#34;, label=label)

    # Simpler view of the nwk graph where only one edge is drawed between
    # two nodes
    @classmethod
    def node_visu_nwklink(cls, tx, label):
        tx.run(&#34;match ()-[r:nwkLink]-&gt;() &#34;
               &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
               &#34;where (r.nwksrc in n_src.nwksrc) and r.nwkdst in n_dst.nwksrc &#34;
               &#34;merge (n_src)-[:layer3]-&gt;(n_dst)&#34;,
               label=label
        )

    # Simpler view of the trans graph where only one type of application is
    # displayed
    @classmethod
    def node_visu_translink(cls, tx):
        tx.run(&#34;&#34;&#34;
        match (n)-[rl3: layer3]-&gt;(m)
        match (n2: Node{label:&#39;5&#39;})-[r]-&gt;(m2: Node{label:&#39;5&#39;}) 
        where n2.nwksrc in n.nwksrc and m2.nwksrc in m.nwksrc
        merge (n)-[:type(r)]-&gt;(m)
        with rl3
        delete rl3
        &#34;&#34;&#34;)

    # Create edges corresponding to the data link communications
    @classmethod
    def node_transmission(cls, tx, properties):
        dlsrc, dldst = properties[&#39;dlsrc&#39;], properties[&#39;dldst&#39;] 
        tx.run( &#34;&#34;&#34;
        match (n_src: Node) 
        where $dlsrc in n_src.dlsrc 
        match (n_dst: Node) 
        where $dldst in n_dst.dlsrc 
        create (n_src)-[:dlLink $properties]-&gt;(n_dst)&#34;&#34;&#34;, 
        dlsrc=dlsrc, dldst = dldst, properties=properties)

    # Create edges corresponding to the network communications
    @classmethod
    def nwk_transmission(cls, tx, label):  
        tx.run(&#34;match ()-[r_g2:dlLink]-&gt;() &#34;
               &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
               &#34;where (r_g2.dlsrc in n_src.dlsrc and r_g2.nwksrc in n_src.nwksrc) and r_g2.nwkdst in n_dst.nwksrc &#34;
               &#34;create (n_src)-[r:nwkLink { timestamp: r_g2.timestamp, dlsrc: r_g2.dlsrc, dldst: r_g2.dldst, nwksrc: r_g2.nwksrc, nwkdst: r_g2.nwkdst, apptype: r_g2.apptype, data: r_g2.data} ]-&gt;(n_dst)&#34;,
               label=label
        )

    @classmethod
    def transport_transmission(cs, tx, delta, delta2):
        #delta = .6 # It is the time delta between a request and the response

        delta = delta
        
        # Get the source and destination nodes along with their
        # edges according to the apptype
        # results = tx.run(&#34;&#34;&#34;
        # match ()-[r_g3:nwkLink]-&gt;()
        # match (n_src: Node {label: &#39;g3&#39;}), (n_dst: Node {label: &#39;g3&#39;})
        # where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
        # with n_src, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
        # return n_src.nameID, nsrc, mdst, collect(distinct tp)
        # &#34;&#34;&#34;).values()

        results = tx.run(&#34;&#34;&#34;
        match ()-[r_g3:nwkLink]-&gt;()
        match (n_src: Node {label: 3}), (n_dst: Node {label: 3})
        where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
        with n_src.nameID as srcID, n_dst.nameID as dstID, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
        return srcID, nsrc, dstID, mdst, collect(distinct tp)
        &#34;&#34;&#34;).values()

        transNodes = {}
        dstNodes = {}
        label=4
        
        for line in results:
            srcID, srcN, dstID, dstN, txG = line
            dstNodes = {
                dstID: txG
            }
            if srcID in transNodes.keys():
                transNodes[srcID].update(dstNodes)
            else:
                transNodes[srcID] = dstNodes
                transNodes[srcID][&#39;id&#39;] = srcID
                transNodes[srcID][&#39;role&#39;] = []

        # logging.debug(transNodes)
                
        for src in transNodes.keys():
            for dst in transNodes[src].keys():
                if &#39;role&#39; == dst or &#39;id&#39; == dst:
                    continue
                    
                # Communication are only one-way
                source = src
                sink = dst
                
                # Dst only received so Dst is a sink
                # And so we are a one way communication
                if not dst in transNodes.keys():
                    if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                        transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                    srcRole = list(set(transNodes[src][&#39;role&#39;]))
                    dstRole = [&#39;sink&#39;]
                    tx.run(&#34;&#34;&#34;
                    match (n: Node{label: $label}), (m: Node{label: $label})
                    where $srcID = n.nameID and $dstID = m.nameID
                    merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                    on create set n.role = n.role + $srcRole, m.role = m.role + $dstRole
                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=transNodes[source][sink])

                # here we have a one-way communication src to dst
                elif src not in transNodes[dst].keys():
                    if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                        transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                    if &#39;sink&#39; not in transNodes[dst][&#39;role&#39;]:
                        transNodes[dst][&#39;role&#39;].append(&#39;sink&#39;)
                        
                    srcRole = list(set(transNodes[src][&#39;role&#39;]))
                    dstRole = list(set(transNodes[dst][&#39;role&#39;]))
                    tx.run(&#34;&#34;&#34;
                    match (n: Node{label: $label}), (m: Node{label: $label})
                    where $srcID = n.nameID and $dstID = m.nameID
                    merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                    on create set n.role = $srcRole, m.role = $dstRole
                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole = srcRole, dstRole = dstRole, ts=transNodes[source][sink])

                # bidirectionnal communications
                else:
                    tx1 = transNodes[src][dst]
                    tx2 = transNodes[dst][src]

                    lentx1 = len(tx1)
                    lentx2 = len(tx2)

                    #j = 0
                    for t2 in tx2:
                        #for i in range(j, lentx1):
                        for t1 in tx1:
                            #t1 = tx1[i]
                            if t2 &gt; t1 :
                                if t2 - t1 &lt; delta:

                                    #logging.debug(f&#39;TRANSEdge created: {dst} -&gt; {src} with {t2} - {t1}&#39;)
                                    
                                    if &#39;source&#39; not in transNodes[dst][&#39;role&#39;]:
                                        transNodes[dst][&#39;role&#39;].append(&#39;source&#39;)
                                    if &#39;sink&#39; not in transNodes[src][&#39;role&#39;]:
                                        transNodes[src][&#39;role&#39;].append(&#39;sink&#39;)
                                    source = dst
                                    sink = src
                                    srcRole = list(set(transNodes[source][&#39;role&#39;]))
                                    dstRole = list(set(transNodes[sink][&#39;role&#39;]))
                                    tx.run(&#34;&#34;&#34;
                                    match (n: Node{label: $label}), (m: Node{label: $label})
                                    where $srcID = n.nameID and $dstID = m.nameID
                                    merge (n)-[: TRANSEdge {timestamp: $ts, nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
                                    on create set n.role=$srcRole, m.role=$dstRole
                                    &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=tx2)
                                    #j = i
                                    #break
                            else:
                                continue

        #Let&#39;s create controller
        results = tx.run(&#34;&#34;&#34;
        match (n: Node{label: 4})-[r1]-(m: Node{label: 4})-[r2]-(d: Node{label: 4})
        where (&#39;source&#39; in n.role or &#39;controller&#39; in n.role) and (&#39;source&#39; in m.role and &#39;sink&#39; in m.role) and (&#39;sink&#39; in d.role or &#39;controller&#39; in d.role) and n &lt;&gt; d
        with r1.nwksrc as src, r1.nwkdst as ctrl, r2.nwkdst as sink, r1.timestamp as ts1, r2.timestamp as ts2
        return src, ctrl, sink, ts1, ts2
        &#34;&#34;&#34;).values()

        #delta2 = .7
        delta2 = delta2
        
        for line in results:
            source, controller, sink, ts1, ts2 = line

            if isinstance(controller, list):
                controller = controller[0]
            
            for t2 in ts2:
                for t1 in ts1:
                # we get a controller
                    if t2 &gt; t1 and t2 - t1 &lt; delta2:

                        #logging.debug(f&#39;Controller set: {controller} with {source} and {sink} with {t2} - {t1}&#39;)
                        
                        tx.run(&#34;&#34;&#34;
                        match (n: Node{label: $label})
                        where $ctrl in n.nwksrc
                        set n.role = [&#39;controller&#39;]
                        &#34;&#34;&#34;, label=label, ctrl=controller)
        
        
    # Create edges corresponding to the application communications
    # Currently only support AS scheme
    @classmethod
    def application_transmission(cs, tx, delta):
        #delta = 1.5
        delta = delta

        # Select all nodes and edges (here represented by path p) that are involved 
        # in an actuator-sensor scheme.
        results = tx.run(&#34;&#34;&#34;
        match p=(n:Node{label: 4})-[:TRANSEdge*1..]-&gt;(c: Node{label: 4})-[:TRANSEdge*1..]-&gt;(m:Node{label: 4})
        where &#39;source&#39; in n.role and &#39;sink&#39; in m.role and n &lt;&gt; m and &#39;controller&#39; in c.role
        return p
        &#34;&#34;&#34;)

        for result in results:
            nbRel = len(result[&#34;p&#34;].relationships)
            rel = result[&#34;p&#34;].relationships
            count = 1
            for i in range(1, nbRel):
                TX1 = rel[i - 1][&#39;timestamp&#39;]
                TX2 = rel[i][&#39;timestamp&#39;]
                for t2, t1 in ((tx2, tx1) for tx2 in TX2 for tx1 in TX1):
                    if t2 &gt; t1 and t2 - t1 &lt; delta:
                        count += 1
                        break
                    

            #logging.debug(f&#39;Count: {count} and nbRel: {nbRel}&#39;)
            # All relationships are succeeded
            if count == nbRel:
                source, dest1 = rel[0].nodes
                dest1, sink = rel[-1].nodes
                
                tx.run(&#34;&#34;&#34;
                match (n: Node{label: 5}), (m: Node{label: 5})
                where n.nameID = $nameIdn and m.nameID = $nameIdm
                Merge (n)-[: INTERACT {nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
                &#34;&#34;&#34;, nameIdn=source[&#39;nameID&#39;], nameIdm=sink[&#39;nameID&#39;])


    ####
    ###  Following functions are wrappers called by the databaseController 
    ####

    # Call the trans_transmission function to store all the communciations
    # between nodes
    def transGraph(self, delta, delta2):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 2, 4)
            session.write_transaction(self.transport_transmission, delta, delta2)

    # Call the trans_transmission function to store all the communciations
    # between nodes
    def appGraph(self, delta):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 4, 5)
            session.write_transaction(self.application_transmission, delta)

    # Call the nwk_transmission function to store all the communciations
    # between nodes
    def nwkGraph(self):
        with self._driver.session() as session:
            session.write_transaction(self.duplicate_node, 2, 3)
            session.write_transaction(self.nwk_transmission, 3)

            session.write_transaction(self.node_visu_nwklink, &#39;l2&#39;)

    # Call the node_transmission function to store all the communciations
    # between nodes
    def create_nodesTX(self, nodesTX):
        with self._driver.session() as session:
            for t in nodesTX:
                session.write_transaction(self.node_transmission, nodesTX[t])

            session.write_transaction(self.duplicate_node, 2, &#39;l2&#39;)
            session.write_transaction(self.node_visu_dllink, &#39;l2&#39;)

    # Handle the creation of multiple nodes
    # using the neo4j syntax
    def create_nodes(self, nodes):
        with self._driver.session() as session:
            for n in nodes:
                session.write_transaction(self.create_node, n)

    def del_nodes(self, label):
        with self._driver.session() as session:
            session.write_transaction(self.delete_nodes, label)
            session.write_transaction(self.delete_visu_nodes, label)

    def getResults(self):
        values = &#39;&#39;  
        with self._driver.session() as session:
            values = session.run(&#34;&#34;&#34;
                with [&#39;TRANSEdge&#39;, &#39;INTERACT&#39;] as t
                match (n)-[r]-(m)
                where n.nwksrc = r.nwksrc and type(r) in t
                return n.nwksrc, n.role, m.nwksrc, m.role, type(r)
             &#34;&#34;&#34;).values()
        return values

    def getNodes(self):
        with self._driver.session() as session:
            nodes = session.run(&#34;&#34;&#34;
                MATCH (n:Node) 
                with n.nameID as id, n.nwksrc as nwk, n.dlsrc as dl 
                return id, dl, nwk&#34;&#34;&#34;).values()
        return nodes 


    def getNode(self, nodeID):
        with self._driver.session() as session:
            node = session.run(&#34;&#34;&#34;
                MATCH (n:Node)
                where n.nameID = $nodeID
                with n.nameID as id, n.dlsrc as dl, n.nwksrc as nwk
                return id, dl, nwk
                &#34;&#34;&#34;, nodeID = nodeID).values()

        return node[0]

    def maxID(self):
        with self._driver.session() as session:
            maxID = session.run(&#34;&#34;&#34;
                MATCH (n:Node) RETURN MAX(n.nameID)
                &#34;&#34;&#34;).values()

        return maxID[0]

    def removeTX(self):
        with self._driver.session() as session:
            session.write_transaction(self.delete_transmissions)
        
    def removeNode(self, nodeID):
        with self._driver.session() as session:
            ret = session.run(&#34;&#34;&#34;
                MATCH (n:Node)
                where n.nameID = $nodeID
                delete n
                &#34;&#34;&#34;, nodeID = nodeID).values()

        return ret</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.application_transmission"><code class="name flex">
<span>def <span class="ident">application_transmission</span></span>(<span>tx, delta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def application_transmission(cs, tx, delta):
    #delta = 1.5
    delta = delta

    # Select all nodes and edges (here represented by path p) that are involved 
    # in an actuator-sensor scheme.
    results = tx.run(&#34;&#34;&#34;
    match p=(n:Node{label: 4})-[:TRANSEdge*1..]-&gt;(c: Node{label: 4})-[:TRANSEdge*1..]-&gt;(m:Node{label: 4})
    where &#39;source&#39; in n.role and &#39;sink&#39; in m.role and n &lt;&gt; m and &#39;controller&#39; in c.role
    return p
    &#34;&#34;&#34;)

    for result in results:
        nbRel = len(result[&#34;p&#34;].relationships)
        rel = result[&#34;p&#34;].relationships
        count = 1
        for i in range(1, nbRel):
            TX1 = rel[i - 1][&#39;timestamp&#39;]
            TX2 = rel[i][&#39;timestamp&#39;]
            for t2, t1 in ((tx2, tx1) for tx2 in TX2 for tx1 in TX1):
                if t2 &gt; t1 and t2 - t1 &lt; delta:
                    count += 1
                    break
                

        #logging.debug(f&#39;Count: {count} and nbRel: {nbRel}&#39;)
        # All relationships are succeeded
        if count == nbRel:
            source, dest1 = rel[0].nodes
            dest1, sink = rel[-1].nodes
            
            tx.run(&#34;&#34;&#34;
            match (n: Node{label: 5}), (m: Node{label: 5})
            where n.nameID = $nameIdn and m.nameID = $nameIdm
            Merge (n)-[: INTERACT {nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
            &#34;&#34;&#34;, nameIdn=source[&#39;nameID&#39;], nameIdm=sink[&#39;nameID&#39;])</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.create_node"><code class="name flex">
<span>def <span class="ident">create_node</span></span>(<span>tx, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_node(cls, tx, node):
    nameID, dlsrc, nwksrc, label, role = node
    tx.run(&#39;&#39;&#39;
        merge (n: Node {label: $label, nameID: $nameID, dlsrc: $dlsrc, nwksrc: $nwksrc, role:$role})
    &#39;&#39;&#39;, label=label, nameID=nameID, dlsrc=dlsrc, nwksrc=nwksrc, role=role)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.delete_nodes"><code class="name flex">
<span>def <span class="ident">delete_nodes</span></span>(<span>tx, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_nodes(cls, tx, label):
    tx.run(&#34;&#34;&#34;
    MATCH (n: Node)
    where n.label &gt;= $label
    optional match (n)-[r]-()
    delete r, n&#34;&#34;&#34;, label=label
    )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.delete_transmissions"><code class="name flex">
<span>def <span class="ident">delete_transmissions</span></span>(<span>tx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_transmissions(cls, tx):
    tx.run(&#34;&#34;&#34;
    MATCH (n: Node)
    optional match (n)-[r]-()
    delete r&#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.delete_visu_nodes"><code class="name flex">
<span>def <span class="ident">delete_visu_nodes</span></span>(<span>tx, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_visu_nodes(cls, tx, label):
    if label &gt; 3:
        return None
    
    if label == 2:
        tx.run(&#34;&#34;&#34;
        MATCH (n: Node)
        where n.label = &#39;l2&#39;
        optional match (n)-[r]-()
        delete r, n&#34;&#34;&#34;
        )

    tx.run(&#34;&#34;&#34;
    MATCH (n: Node)
    where n.label = &#39;l3&#39;
    optional match (n)-[r]-()
    delete r, n&#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.duplicate_node"><code class="name flex">
<span>def <span class="ident">duplicate_node</span></span>(<span>tx, label_src, label_dst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def duplicate_node(cls, tx, label_src, label_dst):
     tx.run(&#34;&#34;&#34;
     match (n:Node {label: $label_src}) 
     with n as map 
     create (copy:Node {label: $label_dst}) 
     set copy.nameID = map.nameID, copy.dlsrc = map.dlsrc, copy.nwksrc = map.nwksrc, copy.neighbors = map.neighbors, copy.role = map.role
     &#34;&#34;&#34;, label_src=label_src, label_dst=label_dst
     )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.node_transmission"><code class="name flex">
<span>def <span class="ident">node_transmission</span></span>(<span>tx, properties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def node_transmission(cls, tx, properties):
    dlsrc, dldst = properties[&#39;dlsrc&#39;], properties[&#39;dldst&#39;] 
    tx.run( &#34;&#34;&#34;
    match (n_src: Node) 
    where $dlsrc in n_src.dlsrc 
    match (n_dst: Node) 
    where $dldst in n_dst.dlsrc 
    create (n_src)-[:dlLink $properties]-&gt;(n_dst)&#34;&#34;&#34;, 
    dlsrc=dlsrc, dldst = dldst, properties=properties)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.node_visu_dllink"><code class="name flex">
<span>def <span class="ident">node_visu_dllink</span></span>(<span>tx, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def node_visu_dllink(cls, tx, label):
    tx.run(&#34;&#34;&#34;
    match ()-[r: dlLink]-&gt;() 
    match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) 
    where (r.dlsrc in n_src.dlsrc) and r.dldst in n_dst.dlsrc
    merge (n_src)-[:layer2]-&gt;(n_dst)&#34;&#34;&#34;, label=label)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.node_visu_nwklink"><code class="name flex">
<span>def <span class="ident">node_visu_nwklink</span></span>(<span>tx, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def node_visu_nwklink(cls, tx, label):
    tx.run(&#34;match ()-[r:nwkLink]-&gt;() &#34;
           &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
           &#34;where (r.nwksrc in n_src.nwksrc) and r.nwkdst in n_dst.nwksrc &#34;
           &#34;merge (n_src)-[:layer3]-&gt;(n_dst)&#34;,
           label=label
    )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.node_visu_translink"><code class="name flex">
<span>def <span class="ident">node_visu_translink</span></span>(<span>tx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def node_visu_translink(cls, tx):
    tx.run(&#34;&#34;&#34;
    match (n)-[rl3: layer3]-&gt;(m)
    match (n2: Node{label:&#39;5&#39;})-[r]-&gt;(m2: Node{label:&#39;5&#39;}) 
    where n2.nwksrc in n.nwksrc and m2.nwksrc in m.nwksrc
    merge (n)-[:type(r)]-&gt;(m)
    with rl3
    delete rl3
    &#34;&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.nwk_transmission"><code class="name flex">
<span>def <span class="ident">nwk_transmission</span></span>(<span>tx, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def nwk_transmission(cls, tx, label):  
    tx.run(&#34;match ()-[r_g2:dlLink]-&gt;() &#34;
           &#34;match (n_src: Node {label: $label}), (n_dst: Node {label: $label}) &#34;
           &#34;where (r_g2.dlsrc in n_src.dlsrc and r_g2.nwksrc in n_src.nwksrc) and r_g2.nwkdst in n_dst.nwksrc &#34;
           &#34;create (n_src)-[r:nwkLink { timestamp: r_g2.timestamp, dlsrc: r_g2.dlsrc, dldst: r_g2.dldst, nwksrc: r_g2.nwksrc, nwkdst: r_g2.nwkdst, apptype: r_g2.apptype, data: r_g2.data} ]-&gt;(n_dst)&#34;,
           label=label
    )</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.transport_transmission"><code class="name flex">
<span>def <span class="ident">transport_transmission</span></span>(<span>tx, delta, delta2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def transport_transmission(cs, tx, delta, delta2):
    #delta = .6 # It is the time delta between a request and the response

    delta = delta
    
    # Get the source and destination nodes along with their
    # edges according to the apptype
    # results = tx.run(&#34;&#34;&#34;
    # match ()-[r_g3:nwkLink]-&gt;()
    # match (n_src: Node {label: &#39;g3&#39;}), (n_dst: Node {label: &#39;g3&#39;})
    # where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
    # with n_src, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
    # return n_src.nameID, nsrc, mdst, collect(distinct tp)
    # &#34;&#34;&#34;).values()

    results = tx.run(&#34;&#34;&#34;
    match ()-[r_g3:nwkLink]-&gt;()
    match (n_src: Node {label: 3}), (n_dst: Node {label: 3})
    where (r_g3.nwksrc in n_src.nwksrc) and r_g3.nwkdst in n_dst.nwksrc
    with n_src.nameID as srcID, n_dst.nameID as dstID, r_g3.nwksrc as nsrc , r_g3.nwkdst as mdst, r_g3.timestamp as tp order by tp
    return srcID, nsrc, dstID, mdst, collect(distinct tp)
    &#34;&#34;&#34;).values()

    transNodes = {}
    dstNodes = {}
    label=4
    
    for line in results:
        srcID, srcN, dstID, dstN, txG = line
        dstNodes = {
            dstID: txG
        }
        if srcID in transNodes.keys():
            transNodes[srcID].update(dstNodes)
        else:
            transNodes[srcID] = dstNodes
            transNodes[srcID][&#39;id&#39;] = srcID
            transNodes[srcID][&#39;role&#39;] = []

    # logging.debug(transNodes)
            
    for src in transNodes.keys():
        for dst in transNodes[src].keys():
            if &#39;role&#39; == dst or &#39;id&#39; == dst:
                continue
                
            # Communication are only one-way
            source = src
            sink = dst
            
            # Dst only received so Dst is a sink
            # And so we are a one way communication
            if not dst in transNodes.keys():
                if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                    transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                srcRole = list(set(transNodes[src][&#39;role&#39;]))
                dstRole = [&#39;sink&#39;]
                tx.run(&#34;&#34;&#34;
                match (n: Node{label: $label}), (m: Node{label: $label})
                where $srcID = n.nameID and $dstID = m.nameID
                merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                on create set n.role = n.role + $srcRole, m.role = m.role + $dstRole
                &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=transNodes[source][sink])

            # here we have a one-way communication src to dst
            elif src not in transNodes[dst].keys():
                if &#39;source&#39; not in transNodes[src][&#39;role&#39;]:
                    transNodes[src][&#39;role&#39;].append(&#39;source&#39;)
                if &#39;sink&#39; not in transNodes[dst][&#39;role&#39;]:
                    transNodes[dst][&#39;role&#39;].append(&#39;sink&#39;)
                    
                srcRole = list(set(transNodes[src][&#39;role&#39;]))
                dstRole = list(set(transNodes[dst][&#39;role&#39;]))
                tx.run(&#34;&#34;&#34;
                match (n: Node{label: $label}), (m: Node{label: $label})
                where $srcID = n.nameID and $dstID = m.nameID
                merge (n)-[: TRANSEdge {nwksrc: n.nwksrc, nwkdst: m.nwksrc, timestamp: $ts}]-&gt;(m)
                on create set n.role = $srcRole, m.role = $dstRole
                &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole = srcRole, dstRole = dstRole, ts=transNodes[source][sink])

            # bidirectionnal communications
            else:
                tx1 = transNodes[src][dst]
                tx2 = transNodes[dst][src]

                lentx1 = len(tx1)
                lentx2 = len(tx2)

                #j = 0
                for t2 in tx2:
                    #for i in range(j, lentx1):
                    for t1 in tx1:
                        #t1 = tx1[i]
                        if t2 &gt; t1 :
                            if t2 - t1 &lt; delta:

                                #logging.debug(f&#39;TRANSEdge created: {dst} -&gt; {src} with {t2} - {t1}&#39;)
                                
                                if &#39;source&#39; not in transNodes[dst][&#39;role&#39;]:
                                    transNodes[dst][&#39;role&#39;].append(&#39;source&#39;)
                                if &#39;sink&#39; not in transNodes[src][&#39;role&#39;]:
                                    transNodes[src][&#39;role&#39;].append(&#39;sink&#39;)
                                source = dst
                                sink = src
                                srcRole = list(set(transNodes[source][&#39;role&#39;]))
                                dstRole = list(set(transNodes[sink][&#39;role&#39;]))
                                tx.run(&#34;&#34;&#34;
                                match (n: Node{label: $label}), (m: Node{label: $label})
                                where $srcID = n.nameID and $dstID = m.nameID
                                merge (n)-[: TRANSEdge {timestamp: $ts, nwksrc: n.nwksrc, nwkdst: m.nwksrc}]-&gt;(m)
                                on create set n.role=$srcRole, m.role=$dstRole
                                &#34;&#34;&#34;, label=label, srcID=source, dstID=sink, srcRole=srcRole, dstRole=dstRole, ts=tx2)
                                #j = i
                                #break
                        else:
                            continue

    #Let&#39;s create controller
    results = tx.run(&#34;&#34;&#34;
    match (n: Node{label: 4})-[r1]-(m: Node{label: 4})-[r2]-(d: Node{label: 4})
    where (&#39;source&#39; in n.role or &#39;controller&#39; in n.role) and (&#39;source&#39; in m.role and &#39;sink&#39; in m.role) and (&#39;sink&#39; in d.role or &#39;controller&#39; in d.role) and n &lt;&gt; d
    with r1.nwksrc as src, r1.nwkdst as ctrl, r2.nwkdst as sink, r1.timestamp as ts1, r2.timestamp as ts2
    return src, ctrl, sink, ts1, ts2
    &#34;&#34;&#34;).values()

    #delta2 = .7
    delta2 = delta2
    
    for line in results:
        source, controller, sink, ts1, ts2 = line

        if isinstance(controller, list):
            controller = controller[0]
        
        for t2 in ts2:
            for t1 in ts1:
            # we get a controller
                if t2 &gt; t1 and t2 - t1 &lt; delta2:

                    #logging.debug(f&#39;Controller set: {controller} with {source} and {sink} with {t2} - {t1}&#39;)
                    
                    tx.run(&#34;&#34;&#34;
                    match (n: Node{label: $label})
                    where $ctrl in n.nwksrc
                    set n.role = [&#39;controller&#39;]
                    &#34;&#34;&#34;, label=label, ctrl=controller)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.appGraph"><code class="name flex">
<span>def <span class="ident">appGraph</span></span>(<span>self, delta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appGraph(self, delta):
    with self._driver.session() as session:
        session.write_transaction(self.duplicate_node, 4, 5)
        session.write_transaction(self.application_transmission, delta)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._driver.close()</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.create_nodes"><code class="name flex">
<span>def <span class="ident">create_nodes</span></span>(<span>self, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_nodes(self, nodes):
    with self._driver.session() as session:
        for n in nodes:
            session.write_transaction(self.create_node, n)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.create_nodesTX"><code class="name flex">
<span>def <span class="ident">create_nodesTX</span></span>(<span>self, nodesTX)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_nodesTX(self, nodesTX):
    with self._driver.session() as session:
        for t in nodesTX:
            session.write_transaction(self.node_transmission, nodesTX[t])

        session.write_transaction(self.duplicate_node, 2, &#39;l2&#39;)
        session.write_transaction(self.node_visu_dllink, &#39;l2&#39;)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.del_nodes"><code class="name flex">
<span>def <span class="ident">del_nodes</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_nodes(self, label):
    with self._driver.session() as session:
        session.write_transaction(self.delete_nodes, label)
        session.write_transaction(self.delete_visu_nodes, label)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.getNode"><code class="name flex">
<span>def <span class="ident">getNode</span></span>(<span>self, nodeID)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNode(self, nodeID):
    with self._driver.session() as session:
        node = session.run(&#34;&#34;&#34;
            MATCH (n:Node)
            where n.nameID = $nodeID
            with n.nameID as id, n.dlsrc as dl, n.nwksrc as nwk
            return id, dl, nwk
            &#34;&#34;&#34;, nodeID = nodeID).values()

    return node[0]</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.getNodes"><code class="name flex">
<span>def <span class="ident">getNodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNodes(self):
    with self._driver.session() as session:
        nodes = session.run(&#34;&#34;&#34;
            MATCH (n:Node) 
            with n.nameID as id, n.nwksrc as nwk, n.dlsrc as dl 
            return id, dl, nwk&#34;&#34;&#34;).values()
    return nodes </code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.getResults"><code class="name flex">
<span>def <span class="ident">getResults</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResults(self):
    values = &#39;&#39;  
    with self._driver.session() as session:
        values = session.run(&#34;&#34;&#34;
            with [&#39;TRANSEdge&#39;, &#39;INTERACT&#39;] as t
            match (n)-[r]-(m)
            where n.nwksrc = r.nwksrc and type(r) in t
            return n.nwksrc, n.role, m.nwksrc, m.role, type(r)
         &#34;&#34;&#34;).values()
    return values</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.maxID"><code class="name flex">
<span>def <span class="ident">maxID</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxID(self):
    with self._driver.session() as session:
        maxID = session.run(&#34;&#34;&#34;
            MATCH (n:Node) RETURN MAX(n.nameID)
            &#34;&#34;&#34;).values()

    return maxID[0]</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.nwkGraph"><code class="name flex">
<span>def <span class="ident">nwkGraph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nwkGraph(self):
    with self._driver.session() as session:
        session.write_transaction(self.duplicate_node, 2, 3)
        session.write_transaction(self.nwk_transmission, 3)

        session.write_transaction(self.node_visu_nwklink, &#39;l2&#39;)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.removeNode"><code class="name flex">
<span>def <span class="ident">removeNode</span></span>(<span>self, nodeID)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeNode(self, nodeID):
    with self._driver.session() as session:
        ret = session.run(&#34;&#34;&#34;
            MATCH (n:Node)
            where n.nameID = $nodeID
            delete n
            &#34;&#34;&#34;, nodeID = nodeID).values()

    return ret</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.removeTX"><code class="name flex">
<span>def <span class="ident">removeTX</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeTX(self):
    with self._driver.session() as session:
        session.write_transaction(self.delete_transmissions)</code></pre>
</details>
</dd>
<dt id="iotmap.database.nodesdatabase.NodesDatabase.transGraph"><code class="name flex">
<span>def <span class="ident">transGraph</span></span>(<span>self, delta, delta2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transGraph(self, delta, delta2):
    with self._driver.session() as session:
        session.write_transaction(self.duplicate_node, 2, 4)
        session.write_transaction(self.transport_transmission, delta, delta2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="iotmap.database" href="index.html">iotmap.database</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="iotmap.database.nodesdatabase.NodesDatabase" href="#iotmap.database.nodesdatabase.NodesDatabase">NodesDatabase</a></code></h4>
<ul class="">
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.appGraph" href="#iotmap.database.nodesdatabase.NodesDatabase.appGraph">appGraph</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.application_transmission" href="#iotmap.database.nodesdatabase.NodesDatabase.application_transmission">application_transmission</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.close" href="#iotmap.database.nodesdatabase.NodesDatabase.close">close</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.create_node" href="#iotmap.database.nodesdatabase.NodesDatabase.create_node">create_node</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.create_nodes" href="#iotmap.database.nodesdatabase.NodesDatabase.create_nodes">create_nodes</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.create_nodesTX" href="#iotmap.database.nodesdatabase.NodesDatabase.create_nodesTX">create_nodesTX</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.del_nodes" href="#iotmap.database.nodesdatabase.NodesDatabase.del_nodes">del_nodes</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.delete_nodes" href="#iotmap.database.nodesdatabase.NodesDatabase.delete_nodes">delete_nodes</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.delete_transmissions" href="#iotmap.database.nodesdatabase.NodesDatabase.delete_transmissions">delete_transmissions</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.delete_visu_nodes" href="#iotmap.database.nodesdatabase.NodesDatabase.delete_visu_nodes">delete_visu_nodes</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.duplicate_node" href="#iotmap.database.nodesdatabase.NodesDatabase.duplicate_node">duplicate_node</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.getNode" href="#iotmap.database.nodesdatabase.NodesDatabase.getNode">getNode</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.getNodes" href="#iotmap.database.nodesdatabase.NodesDatabase.getNodes">getNodes</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.getResults" href="#iotmap.database.nodesdatabase.NodesDatabase.getResults">getResults</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.maxID" href="#iotmap.database.nodesdatabase.NodesDatabase.maxID">maxID</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.node_transmission" href="#iotmap.database.nodesdatabase.NodesDatabase.node_transmission">node_transmission</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.node_visu_dllink" href="#iotmap.database.nodesdatabase.NodesDatabase.node_visu_dllink">node_visu_dllink</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.node_visu_nwklink" href="#iotmap.database.nodesdatabase.NodesDatabase.node_visu_nwklink">node_visu_nwklink</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.node_visu_translink" href="#iotmap.database.nodesdatabase.NodesDatabase.node_visu_translink">node_visu_translink</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.nwkGraph" href="#iotmap.database.nodesdatabase.NodesDatabase.nwkGraph">nwkGraph</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.nwk_transmission" href="#iotmap.database.nodesdatabase.NodesDatabase.nwk_transmission">nwk_transmission</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.removeNode" href="#iotmap.database.nodesdatabase.NodesDatabase.removeNode">removeNode</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.removeTX" href="#iotmap.database.nodesdatabase.NodesDatabase.removeTX">removeTX</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.transGraph" href="#iotmap.database.nodesdatabase.NodesDatabase.transGraph">transGraph</a></code></li>
<li><code><a title="iotmap.database.nodesdatabase.NodesDatabase.transport_transmission" href="#iotmap.database.nodesdatabase.NodesDatabase.transport_transmission">transport_transmission</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>